import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/integrations/supabase/client';
import { toast } from '@/components/ui/use-toast';

export interface SimpleQuestion {
  id: string;
  question_text: string;
  options: string[];
  correct_answer: string;
  explanation?: string;
  topic_id: string;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

export interface QuizAnswerDetail {
  questionId: string;
  userAnswer: string;
  correctAnswer: string;
  isCorrect: boolean;
}

interface QuizSession {
  id: string;
  user_id: string;
  topic_id: string;
  started_at: string;
  completed_at?: string;
  total_questions: number;
  correct_answers: number;
  score_percentage: number;
  time_spent_ms: number;
  question_details: any; // Using any to handle JSONB data
}

export const useSimpleQuiz = (topicId?: string) => {
  const { user } = useAuth();
  const [questions, setQuestions] = useState<SimpleQuestion[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
  const [userAnswers, setUserAnswers] = useState<(string | null)[]>([]);
  const [questionDetails, setQuestionDetails] = useState<QuizAnswerDetail[]>([]);
  const [correctAnswersCount, setCorrectAnswersCount] = useState(0);
  
  const [quizStarted, setQuizStarted] = useState(false);
  const [quizCompleted, setQuizCompleted] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Validation states
  const [isValidating, setIsValidating] = useState(false);
  const [validationResult, setValidationResult] = useState<{
    isCorrect?: boolean;
    correctAnswer?: string;
    explanation?: string;
  } | null>(null);
  
  // Timer
  const [startTime, setStartTime] = useState<number>(0);
  const [elapsedTime, setElapsedTime] = useState(0);
  
  // Current quiz session
  const [currentSession, setCurrentSession] = useState<QuizSession | null>(null);

  // Format time helper
  const formatTime = useCallback((ms: number): string => {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }, []);

  // Update timer
  useEffect(() => {
    let interval: NodeJS.Timeout;
    if (quizStarted && !quizCompleted && startTime > 0) {
      interval = setInterval(() => {
        setElapsedTime(Date.now() - startTime);
      }, 1000);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [quizStarted, quizCompleted, startTime]);

  // Load questions using secure functions
  const loadQuestions = useCallback(async (topicId: string) => {
    try {
      setIsLoading(true);
      setError(null);
      
      console.log('üîç Loading questions for topic:', topicId);
      
      // Use secure function to get questions (without answers)
      const { data: secureQuestions, error: secureError } = await supabase
        .rpc('get_secure_quiz_questions', {
          p_topic_id: topicId,
          p_limit: 15
        });

      if (secureError) {
        console.error('Error fetching secure questions:', secureError);
        throw new Error('Failed to fetch questions securely');
      }

      if (secureQuestions && secureQuestions.length >= 10) {
        console.log('‚úÖ Using secure questions from database');
        
        // Transform secure questions (note: no correct_answer available)
        const transformedQuestions: SimpleQuestion[] = secureQuestions.map(q => ({
          id: q.id,
          question_text: q.question_text,
          options: Array.isArray(q.options) ? q.options : JSON.parse(q.options as string),
          correct_answer: '', // Not available in secure fetch
          explanation: undefined, // Not available in secure fetch
          topic_id: q.topic_id,
          difficulty: q.difficulty as 'beginner' | 'intermediate' | 'advanced'
        }));
        
        setQuestions(transformedQuestions);
        setUserAnswers(new Array(transformedQuestions.length).fill(null));
        return;
      }

      // Generate new questions using AI
      console.log('ü§ñ Generating new questions using AI...');
      
      const response = await supabase.functions.invoke('generate-quiz-questions', {
        body: { topicId, difficulty: 'mixed' }
      });

      if (response.error) {
        console.error('Edge function error:', response.error);
        throw new Error(`Failed to generate questions: ${response.error.message || 'Unknown error'}`);
      }

      const { questions: aiQuestions, timeLimit } = response.data;
      
      if (!aiQuestions || aiQuestions.length === 0) {
        throw new Error('No questions generated by AI service');
      }

      console.log(`ü§ñ AI generated ${aiQuestions.length} questions, now checking database...`);

      // After AI generation, try to fetch from database again as questions should be stored
      const { data: freshQuestions, error: freshError } = await supabase
        .rpc('get_secure_quiz_questions', {
          p_topic_id: topicId,
          p_limit: 15
        });

      if (!freshError && freshQuestions && freshQuestions.length >= 10) {
        console.log('‚úÖ Using freshly stored questions from database');
        
        const transformedQuestions: SimpleQuestion[] = freshQuestions.map(q => ({
          id: q.id,
          question_text: q.question_text,
          options: Array.isArray(q.options) ? q.options : JSON.parse(q.options as string),
          correct_answer: '', // Not available in secure fetch
          explanation: undefined, // Not available in secure fetch
          topic_id: q.topic_id,
          difficulty: q.difficulty as 'beginner' | 'intermediate' | 'advanced'
        }));
        
        setQuestions(transformedQuestions);
        setUserAnswers(new Array(transformedQuestions.length).fill(null));
        return;
      }

      // Fallback: Use AI questions directly (remove sensitive data for client)
      const quizQuestions = aiQuestions.slice(0, 15).map((q: any) => ({
        id: q.id,
        question_text: q.question_text,
        options: q.options,
        correct_answer: '', // Remove correct answer from client
        explanation: undefined, // Remove explanation from client
        topic_id: q.topic_id,
        difficulty: q.difficulty || 'intermediate'
      }));
      
      console.log('‚úÖ Using AI-generated questions directly:', quizQuestions.length);
      setQuestions(quizQuestions);
      setUserAnswers(new Array(quizQuestions.length).fill(null));
      
    } catch (err) {
      console.error('‚ùå Error loading questions:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to load questions';
      setError(errorMessage);
      toast({
        title: "Error loading quiz",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Start quiz
  const startQuiz = useCallback(async () => {
    if (!user || !topicId) {
      toast({
        title: "Authentication required",
        description: "Please log in to start the quiz",
        variant: "destructive",
      });
      return;
    }

    try {
      setIsLoading(true);
      
      // Create quiz session in database
      const { data: session, error: sessionError } = await supabase
        .from('quiz_sessions')
        .insert({
          user_id: user.id,
          topic_id: topicId,
          total_questions: questions.length,
          correct_answers: 0,
          score_percentage: 0,
          time_spent_ms: 0,
          question_details: []
        })
        .select()
        .single();

      if (sessionError) {
        console.error('Error creating quiz session:', sessionError);
        throw new Error('Failed to start quiz session');
      }

      setCurrentSession(session);
      setQuizStarted(true);
      setStartTime(Date.now());
      setCurrentQuestionIndex(0);
      setSelectedAnswer(null);
      setQuestionDetails([]);
      setCorrectAnswersCount(0);
      
      console.log('üöÄ Quiz started:', session.id);
      
    } catch (err) {
      console.error('‚ùå Error starting quiz:', err);
      toast({
        title: "Error starting quiz",
        description: err instanceof Error ? err.message : 'Failed to start quiz',
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [user, topicId, questions.length]);

  // Validate answer using secure function with retry logic
  const validateAnswer = useCallback(async (questionId: string, userAnswer: string, retryCount = 0) => {
    try {
      console.log(`üîç Validating answer for question: ${questionId}`, {
        questionId,
        userAnswer,
        retryCount,
        timestamp: new Date().toISOString()
      });
      
      const { data, error } = await supabase
        .rpc('validate_quiz_answer', {
          p_question_id: questionId,
          p_user_answer: userAnswer
        });

      if (error) {
        console.error('‚ùå RPC validation error:', error);
        
        // Retry once if it's a network or temporary error
        if (retryCount < 1 && (error.message.includes('network') || error.message.includes('timeout'))) {
          console.log('üîÑ Retrying answer validation...');
          await new Promise(resolve => setTimeout(resolve, 1000));
          return validateAnswer(questionId, userAnswer, retryCount + 1);
        }
        
        return { 
          isCorrect: false, 
          correct_answer: '', 
          explanation: 'Unable to validate answer. Please try again.',
          error: error.message 
        };
      }

      // Ensure we have data
      if (!data) {
        console.error('‚ùå No data returned from validation');
        return { 
          isCorrect: false, 
          correct_answer: '', 
          explanation: 'No response from validation service'
        };
      }

      // Handle both direct object and array response formats
      const validationData = Array.isArray(data) && data.length > 0 ? data[0] : data;
      
      // Extract properties from server response
      const rawResult = validationData as { 
        is_correct?: boolean; 
        correct_answer?: string; 
        explanation?: string; 
        error?: string; 
      };
      
      if (rawResult?.error) {
        console.error('‚ùå Validation result error:', rawResult.error);
        return { 
          isCorrect: false, 
          correct_answer: rawResult.correct_answer || '', 
          explanation: rawResult.error 
        };
      }
      
      // Transform server response to client format (is_correct -> isCorrect)
      const transformedResult = {
        isCorrect: Boolean(rawResult.is_correct),
        correct_answer: rawResult.correct_answer || '',
        explanation: rawResult.explanation || ''
      };
      
      console.log(`‚úÖ Answer validation successful:`, {
        questionId,
        userAnswer,
        serverResponse: rawResult,
        transformedResult,
        timestamp: new Date().toISOString()
      });
      
      return transformedResult;
      
    } catch (err) {
      console.error('‚ùå Error in answer validation:', err);
      
      // Retry once for unexpected errors
      if (retryCount < 1) {
        console.log('üîÑ Retrying answer validation after error...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        return validateAnswer(questionId, userAnswer, retryCount + 1);
      }
      
      return { 
        isCorrect: false, 
        correct_answer: '', 
        explanation: 'Validation failed. Please try again.',
        error: err instanceof Error ? err.message : 'Unknown error'
      };
    }
  }, []);

  // Handle answer selection with immediate validation
  const handleAnswerSelect = useCallback(async (answer: string) => {
    setSelectedAnswer(answer);
    setValidationResult(null);
    
    // Update user answers array
    setUserAnswers(prev => {
      const updated = [...prev];
      updated[currentQuestionIndex] = answer;
      return updated;
    });

    // Immediate validation for feedback
    const currentQuestion = questions[currentQuestionIndex];
    if (currentQuestion?.id) {
      setIsValidating(true);
      try {
        const result = await validateAnswer(currentQuestion.id, answer);
        setValidationResult({
          isCorrect: result.isCorrect,
          correctAnswer: result.correct_answer,
          explanation: result.explanation
        });
      } catch (error) {
        console.error('Error in immediate validation:', error);
      } finally {
        setIsValidating(false);
      }
    }
  }, [currentQuestionIndex, questions, validateAnswer]);

  // Go to next question
  const goToNextQuestion = useCallback(async () => {
    if (!selectedAnswer || !questions[currentQuestionIndex]) return;

    const currentQuestion = questions[currentQuestionIndex];
    
    console.log('üìù Processing question answer:', {
      questionId: currentQuestion.id,
      userAnswer: selectedAnswer,
      questionIndex: currentQuestionIndex
    });
    
    // Validate answer using secure function
    const validationResult = await validateAnswer(currentQuestion.id, selectedAnswer);
    const isCorrect = validationResult.isCorrect; // Use transformed property name
    
    console.log('üìä Question validation complete:', {
      questionId: currentQuestion.id,
      isCorrect,
      correctAnswer: validationResult.correct_answer,
      currentCorrectCount: correctAnswersCount
    });
    
    // Add to question details with correct answer from server
    const questionDetail: QuizAnswerDetail = {
      questionId: currentQuestion.id,
      userAnswer: selectedAnswer,
      correctAnswer: validationResult.correct_answer,
      isCorrect
    };
    
    setQuestionDetails(prev => {
      const updated = [...prev, questionDetail];
      console.log('üìã Updated question details:', updated.length, 'total questions processed');
      return updated;
    });
    
    if (isCorrect) {
      setCorrectAnswersCount(prev => {
        const newCount = prev + 1;
        console.log('‚úÖ Correct answer! New count:', newCount);
        return newCount;
      });
    } else {
      console.log('‚ùå Incorrect answer. Count remains:', correctAnswersCount);
    }

    // Move to next question or complete quiz
    if (currentQuestionIndex < questions.length - 1) {
      setCurrentQuestionIndex(prev => prev + 1);
      setSelectedAnswer(null);
      setValidationResult(null); // Clear validation for next question
    } else {
      console.log('üèÅ Quiz complete, finishing...');
      completeQuiz();
    }
  }, [selectedAnswer, questions, currentQuestionIndex, validateAnswer, correctAnswersCount]);

  // Complete quiz
  const completeQuiz = useCallback(async () => {
    if (!currentSession || !user) return;

    try {
      setIsLoading(true);
      
      const totalElapsed = Date.now() - startTime;
      
      // Handle final question validation if needed
      let finalQuestionDetails = [...questionDetails];
      let finalCorrectCount = correctAnswersCount;
      
      if (selectedAnswer && questions[currentQuestionIndex]) {
        console.log('üîö Processing final question in completeQuiz');
        const currentQuestion = questions[currentQuestionIndex];
        const validationResult = await validateAnswer(currentQuestion.id, selectedAnswer);
        const isCorrect = validationResult.isCorrect; // Use transformed property name
        
        console.log('üéØ Final question result:', { isCorrect, correctAnswer: validationResult.correct_answer });
        
        if (isCorrect) {
          finalCorrectCount += 1;
        }
        
        finalQuestionDetails.push({
          questionId: currentQuestion.id,
          userAnswer: selectedAnswer,
          correctAnswer: validationResult.correct_answer,
          isCorrect
        });
      }
      
      const scorePercentage = Math.round((finalCorrectCount / questions.length) * 100);

      console.log('üìä Final quiz statistics:', {
        finalCorrectCount,
        totalQuestions: questions.length,
        scorePercentage,
        questionDetails: finalQuestionDetails.length,
        timeElapsed: totalElapsed
      });

      // Update quiz session
      const { error: updateError } = await supabase
        .from('quiz_sessions')
        .update({
          completed_at: new Date().toISOString(),
          correct_answers: finalCorrectCount,
          score_percentage: scorePercentage,
          time_spent_ms: totalElapsed,
          question_details: JSON.stringify(finalQuestionDetails)
        })
        .eq('id', currentSession.id);

      if (updateError) {
        console.error('‚ùå Error updating quiz session:', updateError);
        throw new Error('Failed to save quiz results');
      } else {
        console.log('‚úÖ Quiz session updated successfully');
      }

      // Also insert into quiz_results for backward compatibility
      const { error: resultsError } = await supabase
        .from('quiz_results')
        .insert([{
          user_id: user.id,
          topic: topicId || 'unknown',
          score: scorePercentage,
          completion_time: Math.floor(totalElapsed / 1000),
          question_details: finalQuestionDetails as any
        }]);

      if (resultsError) {
        console.error('‚ùå Error saving quiz results:', resultsError);
      } else {
        console.log('‚úÖ Quiz results saved to quiz_results table');
      }

      // Update performance tables
      const { error: perfError } = await supabase
        .rpc('update_user_performance', {
          p_user_id: user.id,
          p_topic: topicId || 'unknown',
          p_score: scorePercentage,
          p_completion_time: totalElapsed
        });

      if (perfError) {
        console.error('‚ùå Error updating performance:', perfError);
      } else {
        console.log('‚úÖ User performance updated successfully');
      }

      setQuizCompleted(true);
      setCorrectAnswersCount(finalCorrectCount);
      
      console.log('üéâ Quiz completion process finished:', {
        score: finalCorrectCount,
        total: questions.length,
        percentage: scorePercentage,
        saved: !updateError && !resultsError && !perfError
      });

      toast({
        title: "Quiz completed!",
        description: `You scored ${finalCorrectCount}/${questions.length} (${scorePercentage}%)`,
        variant: "default",
      });

    } catch (err) {
      console.error('‚ùå Error completing quiz:', err);
      toast({
        title: "Error saving results",
        description: err instanceof Error ? err.message : 'Failed to save quiz results',
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [currentSession, user, startTime, correctAnswersCount, selectedAnswer, questions, currentQuestionIndex, questionDetails, topicId, validateAnswer]);

  // Reset quiz
  const resetQuiz = useCallback(() => {
    setQuizStarted(false);
    setQuizCompleted(false);
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setUserAnswers([]);
    setQuestionDetails([]);
    setCorrectAnswersCount(0);
    setStartTime(0);
    setElapsedTime(0);
    setCurrentSession(null);
    setError(null);
    setIsValidating(false);
    setValidationResult(null);
  }, []);

  // Load questions when topic changes
  useEffect(() => {
    if (topicId && !quizStarted) {
      loadQuestions(topicId);
    }
  }, [topicId, quizStarted, loadQuestions]);

  return {
    // State
    questions,
    currentQuestion: questions[currentQuestionIndex] || null,
    currentQuestionIndex,
    totalQuestions: questions.length,
    selectedAnswer,
    userAnswers,
    questionDetails,
    correctAnswersCount,
    quizStarted,
    quizCompleted,
    isLoading,
    error,
    elapsedTime,
    
    // Actions
    handleAnswerSelect,
    goToNextQuestion,
    startQuiz,
    completeQuiz,
    resetQuiz,
    
    // Validation
    isValidating,
    validationResult,

    // Utils
    formatTime,
    
    // Computed
    scorePercentage: questions.length > 0 ? Math.round((correctAnswersCount / questions.length) * 100) : 0
  };
};